import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:hex/hex.dart';
import 'package:test/test.dart';
import 'package:walletkit_dart/src/domain/extensions.dart';
import 'package:walletkit_dart/src/wallet/bip39/bip39.dart';

import '../../utils.dart';

void main() {
  Map<String, dynamic> vectors = json.decode(
    File('./test/ci/bip39/vectors.json').readAsStringSync(encoding: utf8),
  );

  int i = 0;
  (vectors['english'] as List<dynamic>).forEach((list) {
    testVector(list, i);
    i++;
  });

  test(
    "Generate Mnemonic with word arm",
    () {
      int tries = 0;
      bool found = false;
      for (; tries < 20000; tries++) {
        final m = generateMnemonic();
        if (m.endsWith(" arm")) {
          print(
            "After $tries tries: Found random mnemonic that ends with arm: $m",
          );
          found = true;
          break;
        }
      }
      expect(found, true);
    },
  );

  group(
    "Generate Mnemonic with different lengths",
    () {
      test(
        "Generate 12 Word Mnemonic",
        () {
          final phrase = generateMnemonic(strength: 128).split(' ');
          expect(phrase.length, 12);
        },
      );

      test(
        "Generate 15 Word Mnemonic",
        () {
          final phrase = generateMnemonic(strength: 160).split(' ');
          expect(phrase.length, 15);
        },
      );

      test(
        "Generate 18 Word Mnemonic",
        () {
          final phrase = generateMnemonic(strength: 192).split(' ');
          expect(phrase.length, 18);
        },
      );

      test(
        "Generate 21 Word Mnemonic",
        () {
          final phrase = generateMnemonic(strength: 224).split(' ');
          expect(phrase.length, 21);
        },
      );

      test(
        "Generate 24 Word Mnemonic",
        () {
          final phrase = generateMnemonic(strength: 256).split(' ');
          expect(phrase.length, 24);
        },
      );
    },
  );

  group(
    "Validate Mnemonic",
    () {
      test('french phrase generated by legacy app: Test Unicode Replacement',
          () async {
        const frPhrase =
            "sphère horizon sagesse réformer herbe salive tuyau cinéma myriade casque affubler alliage";
        expect(validateMnemonic(frPhrase), false);
        expect(validateMnemonic(frPhrase.replaceUnicode()), true);
      });

      test('spanish phrase generated by legacy app: Test Unicode Replacement',
          () async {
        const esPhrase =
            "cerca cordón liso gamba cierto rudo asistir relleno equipo lagarto árido podio";
        expect(validateMnemonic(esPhrase), false);
        expect(validateMnemonic(esPhrase.replaceUnicode()), true);
      });

      test("Japanese phrase generated by legacy app: Test Unicode Replacement",
          () async {
        const jpPhrase =
            "ほこる すあし あたりまえ とくてん ふっき おつり むしば こんき こうりつ ぴっちり たずさわる すあな";
        expect(validateMnemonic(jpPhrase), false);
        expect(validateMnemonic(jpPhrase.replaceUnicode()), true);
      });

      test('invalid spanish phrase: Test Unicode Replacement', () async {
        const esPhrase =
            "delfín diseño galería inútil jornada lámpara loción maíz mínimo oído página pasión";
        expect(validateMnemonic(esPhrase), false);
        expect(validateMnemonic(esPhrase.replaceUnicode()), false);
      });

      test('invalid french phrase', () async {
        expect(
          validateMnemonic(
            "morning morning morning morning morning morning morning morning morning morning morning hélium",
          ),
          false,
        );
      });

      test("Invalid Japanese Phrase", () async {
        expect(
          validateMnemonic(
            "よごれる じゃま よごれる じゃま よごれる じゃま よごれる じゃま よごれる じゃま よごれる じゃま",
          ),
          false,
        );
      });

      test('garbage phrase', () async {
        expect(validateMnemonic("xyz"), false);
      });
    },
  );

  group('invalid entropy', () {
    test('throws for empty entropy', () {
      try {
        expect(entropyToMnemonic(''), throwsArgumentError);
      } catch (err) {
        expect((err as ArgumentError).message, "Invalid entropy");
      }
    });

    test('throws for entropy that\'s not a multitude of 4 bytes', () {
      try {
        expect(entropyToMnemonic('000000'), throwsArgumentError);
      } catch (err) {
        expect((err as ArgumentError).message, "Invalid entropy");
      }
    });

    test('throws for entropy that is larger than 1024', () {
      try {
        expect(entropyToMnemonic(Uint8List(1028 + 1).join('00')),
            throwsArgumentError);
      } catch (err) {
        expect((err as ArgumentError).message, "Invalid entropy");
      }
    });
  });
  test('validateMnemonic', () {
    expect(
      validateMnemonic('sleep kitten'),
      isFalse,
      reason: 'fails for a mnemonic that is too short',
    );

    expect(
      validateMnemonic('sleep kitten sleep kitten sleep kitten'),
      isFalse,
      reason: 'fails for a mnemonic that is too short',
    );

    expect(
      validateMnemonic(
          'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about end grace oxygen maze bright face loan ticket trial leg cruel lizard bread worry reject journey perfect chef section caught neither install industry'),
      isFalse,
      reason: 'fails for a mnemonic that is too long',
    );

    expect(
      validateMnemonic(
          'turtle front uncle idea crush write shrug there lottery flower risky shell'),
      isFalse,
      reason: 'fails if mnemonic words are not in the word list',
    );

    expect(
      validateMnemonic(
          'sleep kitten sleep kitten sleep kitten sleep kitten sleep kitten sleep kitten'),
      isFalse,
      reason: 'fails for invalid checksum',
    );
  });
  group('generateMnemonic', () {
    test('can vary entropy length', () {
      final words = (generateMnemonic(strength: 160)).split(' ');
      expect(words.length, equals(15),
          reason: 'can vary generated entropy bit length');
    });

    test('requests the exact amount of data from an RNG', () {
      generateMnemonic(
          strength: 160,
          randomBytes: (int size) {
            expect(size, 160 / 8);
            return Uint8List(size);
          });
    });
  });
}

void testVector(List<dynamic> v, int i) {
  final ventropy = v[0];
  final vmnemonic = v[1];
  final vseedHex = v[2];
  //final xpriv = v[3];

  group('for English(${i}), ${ventropy}', () {
    setUp(() {});
    test('mnemoic to entropy', () {
      final String entropy = mnemonicToEntropy(vmnemonic);
      expect(entropy, equals(ventropy));
    });
    test('mnemonic to seed hex', () {
      final seedHex = mnemonicToSeed(vmnemonic, passphrase: "TREZOR").toHex;
      expect(seedHex, equals(vseedHex));

      // TODO: ADD CHeck for xpriv
    });
    test('entropy to mnemonic', () {
      final code = entropyToMnemonic(ventropy);
      expect(code, equals(vmnemonic));
    });
    test('generate mnemonic', () {
      RandomBytes randomBytes = (int size) {
        return Uint8List.fromList(HEX.decode(ventropy));
      };
      final code = generateMnemonic(randomBytes: randomBytes);
      expect(
        code,
        equals(vmnemonic),
        reason: 'generateMnemonic returns randomBytes entropy unmodified',
      );
    });
    test('validate mnemonic', () {
      expect(
        validateMnemonic(vmnemonic),
        isTrue,
        reason: 'validateMnemonic returns true',
      );
    });
  });
}
